# Дополнительные возможности Carrot

## Работа с Carrot Server

### Перенос базы данных между устройствами

**MALPathRedactor** - утилита заменяет пути до ассетов в базе данных перед запуском сервера, чтобы последний не удалял записи об ассетах, файлы которых не смог найти. 

`Использовать при переносе базы данных с одного устройства на другое`

Алгоритм переноса базы данных:

1. Сделать резервную копию своей базы данных.
2. Взять папку **Carrot** с другой машины и заменить свою.
3. Запустить **MALPathRedactor**.
4. Через кнопку `Browse` выбрать путь до файла `mediaAssetLibrary.db` (*по умолчанию AppData\Local\Carrot\DB\mediaAssetLibray.db*).
5. В первом поле указать путь до `Digital Assets`, который был указан в настройках сервера на машине, с которой была взята база данных.
6. Во втором поле пишем путь до новой папки с `Digital Assets`.
7. Нажать кнопку `Apply`.

![MALPathRedactor](..\images\4062\image_069.png "MALPathRedactor")

## Работа с DataStream

### Settings - первоначальная настройка DataStream

>DataBase

- `Directory` - расположение базы данных Carrot.
- `DB autoreplication` -  автоматическая репликация (копирование) базы данных от Host-сервера.
- `Directory` - расположение папки с плагинами.

>Licence
- `Licence Key` - лицензионный ключ для открытия полного функционала Carrot.

>Network
- `Server Host` - имя или IP-адрес Host-сервера.
- `Secure` - используется, если предполагается шифрованное соединение.
- `Reserve Server Host` - имя или IP-адрес резервного сервера.

>Plugins
- `Stop plugin if error` - остановка плагина при возникновении ошибки.

>User
- `Auto Logon` - автоматическое подключение пользователя при запуске приложения.
- `User Name` - имя пользователя (подробнее о правах доступа в [параграфе ?.?](test.md))
- `Password` - пароль пользователя.

---
---

### Начало работы с DataStream

`DataStream` - инструмент предназначенный для быстрого редактирования переменных в плейлисте через **XML** или **XLSX** файлы.

---

#### Описание функций DataStream

Структура приложения представляет собой **три раздела**: `Tables`, `Plugins`, `Settings`.

Разделы `Tables` и `Plugins` имеют схожее построение регионов.

>Таблицы:
- Первый регион: Добавление / Удаление таблиц.
- - `Add Table` - добавить таблицу.
- - `Delete Table` - удалить таблицу.
- Второй регион: Правила выбранной таблицы.
- - `Table Name` - изменить название выбранной таблицы.
- - `Add Cell` - создать ячейку с переменной.
- - `Sort by` - сортировать по: дате создания, дате внесённых изменений, имени.
- - `Unlink Cells` - удалить все связи с плейлистом.
- - `Delete Cells` - удалить ячейку.
- Третий регион: Настройка выбранной ячейки таблицы.
- - `Remove Link` - удалить выбранную связь (*например: удаление изменения параметра внесённого текста в титре*).
- - `Update Cell` - внесение изменений в ячейку (*аналогично кнопке "Сохранить"*).
- - `Cell: Value` - значение переменной: текстовые и численные.
- - `Common: Changed` - дата изменения переменной.
- - `Common: Created` - дата создания переменной.
- - `Common: Name` - имя переменной.

>Плагины:
- Первый регион: Добавление / Удаление плагинов.
- - `Add Plugin` - добавить плагин.
- - `Delete Plugin` - удалить плагин.
- Второй регион: Правила выбранного плагина.
- - `Plugin Name` - изменить название выбранного плагина.
- - `Add Rule` - создать правило. 
- - `Delete Rule` - удалить правило.
- Третий регион: Настройка выбранного правила плагина.
- - `Edit Cells` - добавляет выбранные ячейки для взаимодействия с данным правилом.
- - `Generate cells` - доступно только для **XLSX-таблиц**, создаёт задействованные ячейки в таблице в `DataStream` - `Tables`.
- - `Update Rule` - внесение изменений в правило (*аналогично кнопке "Сохранить"*).
- - `Common: Changed` - дата изменения переменной.
- - `Common: Created` - дата создания переменной.
- - `Common: Name` - имя переменной.
- - `Rule: Enabled` - включить / выключить правило.
- Дополнительный раздел для XML-таблиц.
- - `XML Parser: Path` - местоположения файла с форматом **XML**. 
- - `XML Parser: Update Interval` - интервал проверки файла в секундах. 
- Дополнительный раздел для XLSX-таблиц.
- - `XLSX Parser: Excluder` - исключает выбранную ячейку или диапазон.
- - `XLSX Parser: Path` - местоположения файла с форматом **XLSX**. 
- - `XLSX Parser: Selector` - задаёт строгий диапазон или ячейку для внесения переменных.
- - `XLSX Parser: Sheet Name` - имя листа.
- - `XLSX Parser: Update Interval` - интервал проверки файла в секундах. 
- - `XLSX Parser: Update Type` - при использовании `ByTime` берёт интервал из параметра `Update Interval`, при использовании `ByChange` вносит изменения после каждого сохранения (*данная функция работает не стабильно, рекомендуем использовать параметр* `ByTime`). 

Рассмотрим **три** типа смены данных в переменных шаблона.

---
---

#### Первый тип "Локальный"

1. Перейдём в раздел `Tables`.
![](..\images\image57.png)
![DataStream_Tables_Tables](..\images\DataStream\image_002.jpg "Tables")

2. Нажимаем `Add Table` (*Если необходимо удалить созданную таблицу нажимаем* `Delete Table`).

![DataStream_Tables_Add Table](..\images\DataStream\image_003.jpg "Add Table")

3. Нами была создана таблица с названием по умолчанию "**New Table**". Для удобства работы с таблицами, мы можем переименовать её во втором регионе в разделе `Table Name`. Вводим название, нажимаем `Apply`.

![DataStream_Tables_Table Name](..\images\DataStream\image_004.jpg "Table Name")

4. Далее создаём ячейку через нажатие кнопки `Add Cell`. Одна ячейка хранит одну переменную. Создадим необходимое количество ячеек.

![DataStream_Tables_Add Cell](..\images\DataStream\image_005.jpg "Add Cell")

5. Были созданы ячейки с названием по умолчанию "**NewCell**", для удобства использования переименуем ячейки под конкретные параметры. Для этого в третьем регионе в разделе `Common: Name` удалим старое название и напишем новое. После нажмём на `Update Cell`, чтобы сохранить изменения.

![DataStream_Tables_Common: Name](..\images\DataStream\image_006.jpg "Common: Name")

6. В `After Effects` перейдём в `Export Carrot Template`. 

![DataStream_AE_Export Carrot Template](..\images\DataStream\image_007.jpg "Export Carrot Template")

7. Переносим нужные параметры в раздел переменные `Variables`. Даём название переменным. Сохраняем шаблон через кнопку `Save Template`.

![DataStream_AE_Variables](..\images\DataStream\image_008.gif "Variables")

8. Открываем `WebPlaylist`. Во вкладке `Editor`, выбираем необходимый параметр в шаблоне. Раскрываем меню, нажимаем `Browse`. Выбираем раздел `DataStream`. Перед нами раскрыт список с созданными ранее таблицами, выбираем необходимую. Далее выбираем созданную ранее ячейку. Данная переменная подключена к ячейке `DataStream`, теперь все значения автоматически переносятся из неё в `Playlist`.

![DataStream_WebPlaylist_WebPlaylist](..\images\DataStream\image_009.gif "WebPlaylist")

9. В `DataStream` в третьем регионе мы видим используемые шаблоны и переменные, которые к ним подключены. Поменяем значение в параметре `Cell: Value`. Нажимаем `Update Cell`. **Готово** значение добавленно в переменную в `Playlist`.

![DataStream_Tables_Value](..\images\DataStream\image_010.gif "Value")
![DataStream_Carrot_Result](..\images\DataStream\image_017.jpg "Result_Local")

10. Удалить ссылку на переменную можно несколькими способами:
    
    **Способ №1.** Открываем `Playlist`. Далее `Editor`. Выбираем нужный шаблон и переменную. В раскрывшемся меню нажимаем `Browse` - `DataStream` - Таблица (*с ячейкой*) - Ячейка (*подсвечена красным*) - `Unlink`.

    **Способ №2.** Открываем `DataStream`. Далее в третьем регионе выбираем нужный шаблон и переменную. Нажимаем `Remove Link` в правом верхнем углу.

    **Способ №3.** Выбираем ячейку и нажимаем `Unlink Cells`. Данный способ удаляем все связи в выбранной ячейке.

---
---

#### Второй тип "XML"

1. Аналогично первому типу, проделываем все шаги с [1 по 5](datastream.md#первый-тип-локальный). **Важно! При работе с XML плагином имена созданных ячеек не должны содержать пробелы.**

2. Перейдём в раздел `Plugins`. Добавим плагин через кнопку `Add Plugin`. В открывшемся окне нажимаем на `Set` и указываем путь к файлу. Плагин `XMLParser.dll` лежит в папке `Carrot` - `Bin`.

![DataStream_Plugins_Add Plugin](..\images\DataStream\image_011.gif "Add Plugin")

3. Добавим правило для данного плагина через кнопку `Add Rule`. Это необходимо, чтобы ячейки принимали значения с XML-файла. Данное правило будет работать только после перезапуска приложения `DataStream`. **ПРИМЕЧАНИЕ**: *Если после добавления правила в третьем регионе в разделе `PluginSettings` у вас не появились параметры - удалите плагин, перезапустите `DataStream` и снова добавьте его*.

![DataStream_Plugins_Add Rule](..\images\DataStream\image_012.jpg "Add Rule")

4. Создадим текстовый документ. Внесём в него переменные через "<>". Вводим значения или текст. Сохраняем заменив `.txt` на `.xml`.

![DataStream_Plugins_XML File](..\images\DataStream\image_013.jpg "XML Flie")

5. Чтобы активировать правило, необходимо выставить `Rule: Enabled` - `True`. В `PluginSettings` в `Path` указываем путь к в XML-файлу. В `Update Interval` частоту проверки файла. 

![DataStream_Plugins_Activate Rule](..\images\DataStream\image_014.jpg "Activate Rule")

6. Привяжем XML-файл к созданным ранее ячейкам. Для этого нажимаем `Edit Cells`. Выбираем таблицу. Переносим ячейки через `Add Chosen Table Cells`. Нажимаем `Apply`. Не забудем сохранить изменения через `Update Rule`.

![DataStream_Plugins_Edit Cells](..\images\DataStream\image_015.gif "Edit Cells")

7. Перейдём в `Tables`. Наши ячейки автоматически поменяли значения подставив их из XML-файла.

![DataStream_Plugins_Cells XML](..\images\DataStream\image_016.jpg "Cells XML")

8. Проделаем действия из "Первого типа" [пункт 8](datastream.md#первый-тип-локальный).

![DataStream_Carrot_Result_XML](..\images\DataStream\image_018.gif "Result_XML")

---
---

#### Третий тип "XLSX"

1. В отличии от 1-го и 2-го типа, работу с 3-м нужно начинать с настройки плагина. Аналогично XML-плагину добавим XLSX через `Add Plugin`. Путь к файлу в папке `Carrot` - `Bin` - `XLSXParserV2.dll`.

2. Подготовим таблицу для DataStream. 

![DataStream_XLSX_XLSX](..\images\DataStream\image_019.jpg "XLSX")

3. В `DataStream` добавим правило через `Add Rule` и перезапустим приложение.

4. Активируем плагин через `Rule: Enabled` - `True`. В `PluginSettings` в графе `Path` введём путь к XLSX таблице. В `Selector` указываем диапазон ячеек XLSX файла, которые будут использованы. В `Sheet Name` пропишем название листа с данными. 

![DataStream_Plugin_XLSX Activate](..\images\DataStream\image_020.jpg "XLSX Activate")

5. Аналогично первому типу, проделываем все шаги с [1 по 5](datastream.md#первый-тип-локальный). **Важно! При работе с XLSX плагином имена созданных ячеек должны соответствовать ячейке XLSX таблицы, например: B1, C6, AZ12.**

6. Перезапустим `DataStream`, ячейки автоматически подцепили значения из таблицы. Если мы будем хотим добавить новую ячейку в `Tables` и XLSX файле, то после каждого подцепа нужно перезапускать `DataStream`.

7. Ручное добавление ячеек может быть неудобным, если необходимо вставить большой массив данных. В данном случае можно использовать функцию `Generate cells`. 

![DataStream_Carrot_Result_XLSX](..\images\DataStream\image_021.gif "Result_XLSX")

---
---

### Полезная информация

#### DataStream - автоматизация проигрывания

`DataStream` имеет полезную функцию для автоматического проигрывания анимации с последующей заменой данных в переменной. Для его активации необходимо выполнить несколько простых действий при экспорте шаблона в `Carrot Template Preview`.

1. Перенесём переменные в раздел `Variables`.

2. В каждой перенесённой переменной выставим в графе `DataStream` - `Update Type` - `Call Back`.

3. `Update State` - выставим вариант проигрывания анимации после смены данных.

4. Экспортируем шаблон.

![DataStream_Call Back](..\images\DataStream\image_022.gif "Call Back")

---
---

## Работа с WebPlaylist

### Force Load

В настройках **WebPlaylist Server** есть возможность включить отображение дополнительной кнопки `Force Load` (*по правому клику на выбранный эвент*).

![Carrot WebPlaylist_Force Load](..\images\4062\image_062.jpg "Carrot WebPlaylist - Force Load")

При нажатии на кнопку происходит принудительное повторное скачивание ассетов шаблона и эвента с сервера, даже если ассеты уже были загружены локально.

![Carrot WebPlaylist_Force Load](..\images\4062\image_063.jpg "Carrot WebPlaylist - Force Load")

Данная функция необходима для случаев, когда локальный файл оказался испорчен.

Если же файл испорчен уже на сервере, то его перезапись происходит при пересохранении шаблона в **TemplatePreview**, либо при перезаливе ассетов во вкладке `Browser`-`Media` в вэбе.

### System Monitor

В настройках **WebPlaylist Server** необходимо поставить параметр `Enable System Monitor Page` в положение `True`.

Для отображения имени CarrotServer его также необходимо указать в настройках CarrotServer (поле Server Name)

![Carrot WebPlaylist_System Monitor](..\images\4062\image_064.jpg "Carrot WebPlaylist - System Monitor")

Сама страница содержит две вкладки:
- Media Servers - информация о машинах, где запущены Carrot Server
- Render Stations - информация о машинах, где запущены Carrot Engine

![Carrot WebPlaylist_System Monitor](..\images\4062\image_065.jpg "Carrot WebPlaylist - System Monitor")

- Регион `Hardware` - наличие/отсутсвие рейда, общяя заполненность дисков, оперативной памяти и загрузка ЦП.
- Регион `Network` - инфомация о сетевых картах.
- Регион `Storage` - более детальная информация о дисках в отдельности.
- Регион `Connected Applications` - информация о подключенных приложениях к **CarrotServer**, где в поле `Name` указан объект взаимодействия (*для **Carrot Engine** - имя схемы, для **Web Playlist** - имя открытого плейлиста, для **Template Preview** - имя открытого шаблона*)
- Регион `Connected Users` - отображение авторизованных подключений с указанием времени и адреса.

![Carrot WebPlaylist_System Monitor](..\images\4062\image_066.jpg "Carrot WebPlaylist - System Monitor")

Регион GPU - отображение информации о состянии видеокарты

Регион Carrot Engine - отображение информации о каждом запущенном на машине Carrot Engine. 
В регионе Carrot Engine указана версия ПО, тип лицензии, имя запущенной схемы, частота кадров, тип синхронизации, загрузка ЦП общая и по потокам (рендера, обработки ресурсов и скриптов) и составляющие времени кадра (сейчас указан только ProcessTime)

Также в Carrot Engine есть информация об устройствах ввода и вывода, используемых в схемах (имя, тип и размеры буферов (реальный/выставленный в настройках))

Если серверы находятся в режиме репликации, это тоже будет отображено.

![Carrot WebPlaylist_System Monitor](..\images\4062\image_067.jpg "Carrot WebPlaylist - System Monitor")

---
---

## Работа с GPIO

`Isolated Channels` - данный параметр позволяет каждому из 8-ми каналов обрабатываться отдельно. В этом случае при приходе сигнала будет отображаться не его значение, а номер канала, по которому он пришел.

Привязывать показ эвентов нужно следующим образом: 
- 1 - показ 1й плазмы;
- 2 - показ 2й плазмы;
- 3 - показ 3й плазмы.

Для отслеживания "отжатия" нужно привязать на другое событие номер канала со знаком `-`:
- -1 - скрытие 1й плазмы;
- -2 - скрытие 2й плазмы;
- -3 - скрытие 3й плазмы.

`Log` - в папке `Logs` в файле **InputDevices** будет записываться пришедшее значения и время прихода.

`Invert Input` отвечает за инвертирование значения (в битовом значении), которое пришло. Например, если галка активна, то приходящее значение (**1-1-1-0-0-0-0-0**) будет обрабатываться как (**0-0-0-0-0-1-1-1**).

`Invert Output` вывод инвертированного значения (в битовом значении), которое привязано на событие. Например, если галка активна, то отправляемое значение (**0-0-0-0-0-1-0-1**) будет передано как как (**1-0-1-0-0-0-0-0**).

Если галки `Invert Input` и `Invert Output` выключены, то, например, значение (**0-0-0-0-0-1-1-1**), привязанное к событию, будет передано на вывод без изменений при активации события.

---
---

## Работа с Template Preview

### Полезная информация

#### OverlapIndex в UE Template

Если у двух стейтов одного шаблона `Overlap Index` > 0 и они одинаковые, то первое событие при включении второго перейдет из состояния `Active` в состояние `Ready`.

Если у стейтов `Overlap Index` > 0 и они разные - включение второго события оставит первое не тронутым.

![TemplatePreview_OverlapIndex](..\images\4062\image_061.jpg "Template Preview - OverlapIndex")

---
---

## Работа со State Logic

**State Logic** определяет поведение одного шаблона в зависимости от состояния (*далее **стэйт***) других шаблонов. Например, в выпуске новостей требуется предусмотреть показ титра человека как вместе с темой, так и без неё. В этом случае необходимо создать мастер-шаблон, который будет носителем плэйсхолдеров, вместо которых в веб-плейлисте будут заданы контейнеры шаблонов.

Ноды стэйт-логики:
- Child Template – дочерний шаблон;
- Оператор (OR, AND);
- Стэйты редактируемого шаблона.

![State Logic_Child Template](..\images\4062\image_094.jpg "State Logic - Child Template")

Выходами нода `Child Template` являются стэйты дочернего шаблона.

![State Logic_Operators](..\images\4062\image_095.jpg "State Logic - Operators")

Входы `оператора` – стэйты дочерних шаблонов.
Выход `оператора` – результат логической операции `OR` или `AND` (впоследствии будет добавлен оператор `NOT`).

![State Logic_Enters](..\images\4062\image_096.jpg "State Logic - Enters")

Нод стэйта шаблона имеет только входы. Если на каждый из входов приходит сигнал `true`, то шаблон переходит в данный стэйт.

![State Logic_Child Template](..\images\4062\image_097.jpg "State Logic - Child Template")

Стэйт-логика пакета титров для новостей.

- Шаблон `GEO` – шаблон геотитра.
- Шаблон `Ticker` – бегущая строка.
- Шаблон `Theme` – носитель темы сюжета/выпуска.

![State Logic_1LINE](..\images\4062\image_098.jpg "State Logic - 1LINE")

Стэйт `1LINE` – тема в одну строку.

![State Logic_2LINE](..\images\4062\image_099.jpg "State Logic - 2LINE")

Стэйт `2LINE` – тема в две строки.

![State Logic_HIDE](..\images\4062\image_100.jpg "State Logic - HIDE")

Стэйт `HIDE` – прячет предыдущий текст для замены на новый.

Стэйты в редактируемом шаблоне задают позицию плэйсхолдеров на экране:
- `THEME1` – тема в одну строку.
- `THEME2` – тема в две строки.
- `TICKER` – бегущая строка.
- `TT1` – тема в одну строку плюс бегущая строка.
- `TT2` – тема в две строки плюс бегущая строка.
- `NONE` – ни одного из указанных элементов нет в кадре.

### Порядок действий:

1. Выберите Child Template в списке шаблонов.
2. Подключите стэйт, вызываемое в дочернем шаблоне, к состоянию, которое требуется вызвать в материнском шаблоне.
3. Предусмотрены блоки `OR` и `AND`, объединяющие условия вызова состояний нескольких дочерних шаблонов.
- `OR` инициирует вызов состояния, если хотя бы один из операндов блока `true`.
- `AND` инициирует вызов состояния, если все из операндов блока `true`.
4. Для проверки работы стэйт-логики нажмите кнопку `Test`.

![State Logic_Test](..\images\4062\image_101.jpg "State Logic - Test")

Нажатием на кнопки внутри нодов дочерних шаблонов вызывайте тот или иной стэйт дочернего шаблона. Зелёным светом загорается стэйт, в который перейдёт редактируемый шаблон.

| Стэйт шаблона `Theme` | Стэйт шаблона `Ticker` | Стэйт шаблона `Geo` | Стэйт, который вызовется у редактируемого шаблона |
|:---------------------:|:----------------------:|:-------------------:|:-------------------------------------------------:|
|1LINE                  |IN                      |IN                   |TT1                                                |
|1LINE                  |IN                      |OUT                  |TT1                                                |
|1LINE                  |OUT                     |IN                   |TT1                                                |
|1LINE                  |OUT                     |OUT                  |THEME1                                             |
|2LINES                 |IN                      |IN                   |TT2                                                |
|2LINES                 |IN                      |OUT                  |TT2                                                |
|2LINES                 |OUT                     |IN                   |TT2                                                |
|2LINES                 |OUT                     |OUT                  |THEME2                                             |
|OUT                    |IN                      |IN                   |TICKER                                             |
|OUT                    |IN                      |OUT                  |TICKER                                             |
|OUT                    |OUT                     |IN                   |TICKER                                             |
|OUT                    |OUT                     |OUT                  |NONE                                               |

Комбинация связей между шаблонами должна привести к вызову только одного стэйта. Иначе тест выдаст ошибку, и стэйт-логика может сработать непредсказуемо.

![State Logic_NoneError](..\images\4062\image_102.jpg "State Logic - NoneError")

Если тест Вас устраивает, закройте окно тестирования, и нажмите `Apply`. 

![State Logic_Child Template](..\images\4062\image_103.jpg "State Logic - Child Template")

Если переход в стэйти требуется проиграть, находясь в этом же стэйте, то поставьте галочку 
`Enable Same State Repeated Execution`.

![State Logic_Child Template](..\images\4062\image_104.jpg "State Logic - Child Template")