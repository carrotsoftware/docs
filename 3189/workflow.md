# Работа с ПО Carrot

## Шаг 1. Инициализация и запуск модулей Carrot.

### 1.1. Инициализация компонентов Carrot.

Инициализация настроек `Init Settings` необходима для сопряжения подключаемой сборки, после инициализации **Carrot Launcher** использует данные запущенной версии Carrot.

1. Откроем папку `Carrot`, далее `Bin`.
2. В списке файлов находим `InitSettings.exe`.
3. Запускаем файл от имени администратора.
4. Сборка иниализирована.

![Workflow_Init Settings](..\images\3189\image_015.jpg "Workflow - Init Settings")

---

### 1.2. Запуск компонентов Carrot.

Для начала работы с **Carrot** достаточно запустить `четыре` модуля:

- **Carrot Server** - единое место хранения медиа-контента и баз данных.
- **Carrot Laucher** - модуль для запуска **Carrot Engine**. Используется для настройки и регистрации рабочих станций.
- **Carrot WebPlaylist** - единая система управления контентом для всех **Carrot Engine**.
- **Carrot System Monitor** - модуль для настройки и запуска **Carrot Engine**, а также для централизованного управления шаблонами и медиа контентом.

Разберём каждый из модулей отдельно.

---

### 1.3. Carrot Server.

Запуск модулей **Carrot** всегда начинается с **Carrot Server**, являясь единым местом хранения медиа и баз данных, модуль выполняет роль центра объединяющего все прочие модули.

**Carrot Server** запускается только на одной рабочей машине, на остальных данный модуль не требуется.

1. Запустите модуль **Carrot Server** на рабочей машине, которую планируете использовать как **Host**.

![Workflow_Carrot Server](..\images\3189\image_016.jpg "Workflow - Carrot Server")

2. Убедитесь, что все подключенные модули отображаются в списке подключений. В случае, если модуль не появился в списке, нажмите `Refresh` - **Carrot Server** войдёт в цикл и начнёт поиск модулей, после нахождения нажмите на кнопку ещё раз. Если данный способ не помог, проверьте правильность IP-адреса прописанного в модулях.

![Workflow_Carrot Server_Refresh](..\images\3189\image_017.jpg "Workflow - Carrot Server - Refresh")

---

### 1.4. Launcher. Регистрация рабочей станции.

**Carrot Launcher** необходим для старта **Carrot Engine**. Он позволяет регистрировать и настраивать рабочие станции отдельно на каждом устройстве, где предполагается использование **Carrot Engine**.

1. Запустите приложение **Carrot Launcher** (`Launcher.exe`).
2. В окне `Tools` нажмите на кнопку `Workstation Registration`.
3. Перед вами открыто окно для регистрации и настройки рабочей станции.

>Для `экспорта` и `импорта` готовых пресетов нажмите на `File` и соответствующий раздел.

![Workflow_Workstation Registration](..\images\3189\image_018.jpg "Workflow - Workstation Registration")

4. В поле `Name` введите название рабочей станции. По умолчанию модуль берёт название текущего устройства.

![Workflow_Workstation Registration_Name](..\images\3189\image_019.jpg "Workflow - Workstation Registration - Name")

5. В разделе `Inputs` нажмите на `+` , перед вами раскроется список с возможностями, которые можно использовать в качества входа. Рассмотрим отдельно каждый `Input`.
- `AJA Tracked Input` - используется с картами видеозахвата **AJA**.
- `BMD Input` - используется с картами видеозахвата **Blackmagic Design**.
- `Decklink10Bit` - используется при работе с картой **Decklink** с глубиной цвета `10Bit`.
- `Decklink` - используется при работе с картой **Decklink** с глубиной цвета `8Bit`.
- `Raw Rtc` - используется при работе с подключением по **Web RTC**.
- `BMD Tracked Input` - используется с картами видеозахвата **Blackmagic Design** при использовании трекинговых данных.
- `Texture Input` - используется для вывода изображения или видеофайла на устройстве.
- `Tracked Input` - используется для вывода только трекинг данных.
- `Stream Input` - используется для вывода видеосигнала или аудиосигнала с устройства подключённого к данной рабочей станции. Например: через данный `Input` возможно передать изображение с монитора на один из выходов карты видеозахвата, актуально при воспроизведении презентаций на большом экране.

![Workflow_Workstation Registration_Inputs](..\images\3189\image_020.jpg "Workflow - Workstation Registration - Inputs")

6. В разделе `Outputs` нажмите на `+` , перед вами раскроется список с возможностями, которые можно использовать в качества выхода. Рассмотрим отдельно каждый `Outputs`.
- `AJA Output` - вывод изображения на карту AJA.
- `Bmd Fill/Key Output` - вывод изображений `Fill` и `Key` на карту **Blackmagic Design, Decklink**.
- `Decklink` - вывод изображения на карту **Decklink**.
- `DecklinkFillKey` (*устаревший*) - вывод изображений `Fill` и `Key` на карту **Decklink**.
- `Screen Output` - вывод изображения на экран монитора.
- `WebSocket Stream Output` - вывод изображения с одной рабочей станции **Carrot** на другую по локальной сети.
- `Stream Output` - вывод изображения на стриминговый сервис (*например: YouTube*).
- `XR Output` - .

![Workflow_Workstation Registration_Outputs](..\images\3189\image_021.jpg "Workflow - Workstation Registration - Outputs")

7. Выберите и настройте входы и выходы для рабочей станции.

![Workflow_Workstation Registration_Inputs&Outputs](..\images\3189\image_022.jpg "Workflow - Workstation Registration - Inputs&Outputs")

8. Нажмите `Register/Update` для регистрации рабочий станции в **Carrot**.
9. В появившемся окне нажмите `ОК`.

![Workflow_Workstation Registration_Register](..\images\3189\image_023.jpg "Workflow - Workstation Registration - Register")

10. Ваша рабочая станция зарегистрирована в **Carrot**.

![Workflow_Workstation Registration_Succesful](..\images\3189\image_024.jpg "Workflow - Workstation Registration - Succesful")

>При необходимости удалить рабочую станцию из базы данных **Carrot Server** нажмите `UnRegister`.

---

### 1.5. WebPlaylist. 

**Carrot WebPlaylist** - единая система управления контентом для всех **Carrot Engine**. Данный компонент состоит из двух модулей:
- **WebPlaylist** - сервер веб-плейлиста.
- **WebPlaylistSettings** - настройка сервера веб-плейлиста.

Для активации плейлиста в браузере, достаточно запустить приложение `WebPlaylist.exe`.

Если сервер плейлиста запущен правильно, должно появиться следующее окно.

![Workflow_WebPlaylist](..\images\3189\image_006.jpg "Workflow - WebPlaylist")

---

### 1.6. System Monitor. Создание схемы в Carrot Flowchart.

**Carrot System Monitor** - модуль для настройки и запуска **Carrot Engine**, а также для централизованного управления шаблонами и медиа контентом.

**Carrot Engine** производит обработку изображения в соответствии со схемой, составленной в **System Monitor**.

> Как создать движок и добавить в него рабочие станции?

1. Перейдите во вкладку `Engines`.
2. Добавьте новую директорию нажав на `Add Folder`, либо выберите уже существующую.
3. Нажмите кнопку `Add Engine`.
4. Введите название движка и нажмите `ОК`.
5. Нажмите кнопку `Add Workstation` и выберите рабочие станции, которые будут задействованы в схеме.

![Workflow_System Monitor_Engines](..\images\3189\image_025.gif "Workflow - System Monitor - Engines")

> Как настроить схему для работы с движком?

1. Нажмите `Edit Scheme` - откроется окно `Engine Flowchart`.
2. Добавьте ноды ввода перетаскиванием из раздела `Registered inputs`.
3. Добавьте одну ноду вывода перетаскиванием из раздела `Registered outputs`.
4. Кликнув ПКМ по пустому месту выберите тип добавляемой ноды.
5. Соедините ноды.
6. Сохраните составленную схему нажатием кнопки `Save`.

![Workflow_System Monitor_FlowChart](..\images\3189\image_026.gif "Workflow - System Monitor - FlowChart")

Подробнее с нодами можно ознакомиться ниже:

>`Container` - используется для проигрывания AE и UE шаблонов.
>
>`Keyer` - используется для замены заднего фона изображения на другое изображение.
> - Пин `Foreground` принимает изображение, задний фон которого необходимо заменить.
> - Пин `Background` принимает изображение, на которое будет заменен задний фон.
>
>`AR` - служит для добавление объектов дополненной реальности.
> - Пин `Foreground` принимает изображение объекта который необходимо наложить.
> - Пин `Background` принимает изображение заднего фона.
>
>`Luma` - .
> - Пин `Foreground` принимает изображение .
> - Пин `Background` принимает изображение .
> - Пин `Luma` 
>
>`Viewport` - служит для прямого наложения нескольких веток друг на друга.

Данные ноды могут изменять следующие характеристики:
- Положение относительно левого верхнего угла (параметры X, Y).
- Размер изображения на выходе (параметры Width, Height).

> **Примечание:** если рассматривать ноды в качестве слоёв, то на итоговом изображении слои накладываются друг поверх друга начиная от ноды ввода к ноде вывода.

---
---

## Шаг 2. Подготовка плейлиста.





## Настройка Carrot Keyer

### Настройка Mask

Зайдите `Carrot Keyer` -> `Key` -> `Alpha Mask` -> `Key color` -> `Pick` и выберите цвет который необходимо убрать.

![](..\images\image166.png)

Нам необходимо убрать верхнюю часть кадра с оборудованием:

![](..\images\image47.png)

- выберете в `Mode` -> `Alpha mask`

  В **Carrot Engine** включиться отображение `Alpha mask`.

- Перейдите в `Carrot Keyer` -> `Mask` -> `Scene` - > `Filename`

![](..\images\image98.png)

И выберете модель вашей студии в формате `.fbx`

Модель должна содержать в себе следующие объекты:

1. Модель вашей циклорамы.
2. Модель помещения студии.
3. Захватчик отражений (если вы его используете).
4. Специальные объекты (при использовании excluder).

Они отобразятся в разделе `Objects`.

![](..\images\image153.png)

Теперь каждому объекту надо указать его назначение.
Для этого щелкните по объекту `ЛКМ` и в разделе `ObjType` выберите его тип:

![](..\images\image135.png)

В разделе `Object offsets` можно изменить местоположение угол поворота и размер объектов

Объекты вашей модели должны совпасть по положению с реальными результат должен выглядеть примерно так:

![](..\images\image63.png)

Так же при статических камерах возможно использовать маски в формате `.png`

Для этого переключите `Mask type` -> `Texture`

И в разделе `Scene` -> `Filename` укажите путь к файлу:

![](..\images\image98.png)

За тип маски в данном случае будет отвечать канал в пикселе изображения:

- Канал `Red` - Chromakey BG
- Канал `Blue` - VR BG
- Канал `Green` - Chromakey Floor

Результат работы масок:

![](..\images\image74.png)

![](..\images\image45.png)

## **Подготовка проекта в After Effects для экспорта в Carrot**

### Настройки композиции

1. Запустите Adobe After Effects.
2. Откройте проект.
3. На панели **Project** откройте корневую композицию, которую хотите экспортировать.
   ![](..\images\workflow_AE\stage_01.png)

4. Выберите меню **Composition** > **Composition Settings...** или нажмите клавиши **CTRL**+**K**
   ![](..\images\workflow_AE\stage_02.png)

5. Проверьте разрешение и частоту кадров композиции.
   ![](..\images\workflow_AE\stage_03.png)

   > Частота кадров композиции должна совпадать с частотой кадров видеотракта.<br>
   > <br>Разрешение композиции должно совпадать с разрешением контейнера в схеме движка Carrot.
   > ![](..\images\workflow_AE\stage_04.png)

6. Удалите из проекта все неиспользуемые элементы. Для этого выберите **File** > **Dependencies** > **Remove Unused Footage**.
   ![](..\images\workflow_AE\stage_07.png)

### Указание точек входа и выхода анимации

![](..\images\image152.png)

Для того, чтобы Carrot распознал отрезки анимации, пользователю требуется выставить маркеры композиции. Композиция должна содержать минимум 3 маркера. Если в других композициях присутствуют какие-либо маркеры, то их следует удалить.

Для того, чтобы добавить маркера:

1. Переместите ползунок в начало композиции (или анимации) и поставьте первый маркер с помощью клавиши **Numpad «\*»** на цифровой клавиатуре или выберите **Layer** > **Markers** > **Add Marker**:
   ![](..\images\workflow_AE\stage_06.png)

2. Щелкните правой кнопкой мыши по добавленному маркеру и выберите **Settings...**
   ![](..\images\workflow_AE\stage_05.png)

3. В открывшемся окне измените комментарий маркера на `OUT`.

   ![](..\images\image9.png)

4. Переместите ползунок в середину композиции и поставьте следующий маркер.

   ![](..\images\image174.png)

5. Измените комментарий маркера на `IN`

   ![](..\images\image7.png)

   ![](..\images\image95.png)

6. Переместите ползунок в конец композиции и поставьте следующий маркер.

   ![](..\images\image177.png)

7. Измените комментарий маркера на `OUT`.

   ![](..\images\image9.png)

Расположение маркеров будет выглядеть следующим образом:

![](..\images\image17.png)

Здесь присутствуют два временных промежутка:

- `OUT` - `IN` (в движке именуется как `IN`)
- `IN` - `OUT` (в движке именуется как `OUT`)

Воспроизведение в движке этого шаблона будет выглядеть следующим образом:

- Шаблон не активен, графика не показывается.
- Шаблон активируется, проигрывается область между маркерами `OUT`-`IN`.
- Шаблон активен, графика остаётся на позиции маркера `IN` и именуется как `ACTIVE`.
- Шаблон деактивируется, проигрывается область между маркерами `IN`-`OUT`.

7. Сохраните проект.

### Указание точек дополнительных анимаций

Композиция также может содержать дополнительные анимации помимо стандартных для входа и выхода. Для них также следует добавить маркеры. Для этого:

1. Переместите ползунок в начало желаемой анимации и добавьте новый маркер.
2. Измените комментарий маркера.
3. Переместите ползунок в конец желаемой анимации и добавьте ещё один маркер.
4. Измените комментарий маркера на желаемый.

Пример:

![](..\images\image140.png)

Здесь присутствуют три временных промежутка:

- `OUT` - `IN` (в движке именуется как `IN`)
- `IN` - `ANIM` (в движке именуется как `ANIM`)
- `ANIM` - `OUT` (в движке именуется как `OUT`)

Область между маркерами с одинаковыми именами (в примере `ANIM`-`ANIM`) игнорируется в **Carrot Engine** и пропускается при воспроизведении.

### Дополнительная информация и рекомендации

#### Проект

- Каждый шаблон рекомендуется сохранять в свой отдельный проект **After Effects**.
  > При экспорте шаблона из **After Effects** информация о всех композициях и контенте в проекте (в том числе неиспользуемых) передаётся и обрабатывается движком Carrot.

#### Эффекты

Поддерживаемые эффекты из **After Effects** в **Carrot Engine** в режиме реального времени:

- _Blur & Sharpen_ - **Sharpen**
- _Generate_ - **Fill**
- _Generate_ - **Gradient Ramp**
- _Color Correction_ - **Tritone**
- _Color Correction_ - **Tint**
- _Color Correction_ - **Levels**
- _Color Correction_ - **Curves**
- _Expression Controls_ - **3D Point Control**
- _Expression Controls_ - **Angle Control**
- _Expression Controls_ - **Checkbox Control**
- _Expression Controls_ - **Color Control**
- _Expression Controls_ - **Point Control**
- _Expression Controls_ - **Slider Control**
- _Transition_ - _Wipes_ - **Linear Wipe**

#### Композиции и слои

- Ключи анимации должны располагаться по краям кадров.
  ![](..\images\workflow_AE\stage_08.png)
- Слои, отмеченные в композиции как `Guide Layer` следует скрыть или удалить перед экспортом.
- При использовании логики **IF ELSE** внутри выражений, для корректной обработки в **Carrot Engine**, структура должна выглядеть следующим образом:

  ![](..\images\workflow_AE\stage_09.png)

- Все выражения, которые не требуют обработки в реальном времени, рекомендуется конвертировать в ключи анимации перед экспортом.

Поддерживаемые типы слоев в композиции:

- **Null Layer**
- **Solid Layer**
- **Shape Layer**, конвертированные в кривые Безье (без операций с контурами)
- **Text Layer** (без эффектов аниматора)
- **Media Layer** (MP4, MOV, JPG, PNG, PSD и т.д.)
  > В целях оптимизации шаблона и проекта PSD/AI слои внутри композиции рекомендуется заменить на Solid Layer, либо на готовое изображение PNG или JPG.

Поддерживаемые операции со слоями:

- **Track Matte** (Подложки отслеживания)
- **Parent Link** к другому слою или его свойствам (Привязка)
- **Blending Modes** (Режимы наложения)
- **Masking** (Маски)
- **Expressions** (Выражения)

#### Маски

- Маска в режиме наложения `None` скрывает отображение слоя в **Carrot Engine**.
- Единичную маску в режиме `Intersect` следует поменять на `Add`.
- Свойство `Mask Feather` по умолчанию в **Carrot Engine** использует бикубический режим сэмплинга.

#### Текст

- **Carrot Engine** считывает свойства текста (шрифта, размер, цвет, интервалы и т.д.) по первому символу и применяет их на все остальные символы.
- **Carrot Engine** принудительно применяет для кернинга текста тип `Metrics`.
- Используемые сторонние шрифты рекомендуется устанавливать в систему в формате **OTF**.

#### 3D слои

- **Carrot Engine** считывает систему измерений из After Effects в миллиметрах, т.е. 1000px в **After Effects** = 1000mm в **Carrot Engine**.
- Для вращения слоя следует использовать свойство **Orientation**.

## **Экспорт шаблона из проекта AE**

1. Выберите меню `Composition` - `Export Carrot Template`.

![](..\images\image42.png)

> Примечание: если этот пункт не активен, нажмите на раздел с композициями в нижней части интерфейса **After Effects**. 2. Появится окно **Template Preview**.

    ![](..\images\image30.png)

3. Откройте вкладку `Animation` в центральном разделе `Viewport`.

   ![](..\images\workflow_AE\stage_10.png)

4. В поле `Composition` выберите композицию, которая была экспортирована:
   ![](..\images\image151.png)

Благодаря маркерам здесь появились три стейта:

- `IN` (соответствует промежутку `OUT`-`IN`)
- `ANIM` (соответствует промежутку `IN`-`ANIM`)
- `OUT` (соответствует промежутку `ANIM`-`OUT`)

  ![](..\images\image140.png)

4. Проверьте правильность воспроизведения анимации:

   1. Нажмите на название стейта.
      ![](..\images\workflow_AE\stage_11.png)

   2. Дождитесь завершения проигрывания.

5. Нажмите кнопку `Save Template`.

   ![](..\images\image69.png)

6. В новом окне выберите директорию для сохранения шаблона.

7. В поле `Name` задайте название шаблона.

8. Нажмите на поле `Container`.

9. В появившемся окне выберите нужную схему движка и укажите соответствующий контейнер.

   ![](..\images\workflow_AE\stage_13.png)

10. Нажмите на кнопку **Save Template**.
11. Закройте **Template Preview**.

### Создание переменных

Текстовые или медиа слои могут выступать в качестве оперативно изменяемых параметров шаблона в **Carrot Web Playlist**:

![](..\images\image120.png)
![](..\images\image100.png)

1. Для назначения слоя в качестве переменной выполните следующее:

   1. Выберите требуемый слой
   2. Зажмите левую кнопку мыши и перетащите его в раздел **Variables**.

   ![](..\images\workflow_AE\stage_14.png)

   2. Выберите созданную переменную
   3. В поле `Name` введите желаемое имя переменной.

   ![](..\images\workflow_AE\stage_12.png) 4. В поле `Type` укажите необходимый тип переменной.

#### Создание текстовой переменной

![](..\images\workflow_AE\result_01.gif)
Для назначения текстового слоя в качестве переменной выполните следующее:

1. Раскройте слой и найдите свойство `Source Text`.
2. Зажмите левую кнопку мыши и перетащите его в раздел **Variables**.

   ![](..\images\image145.png)

   - В поле `Name` введите желаемое имя переменной.
   - В поле `Type` укажите тип `Text` или `RichText`.
     > В случае, если указан тип `RichText`, к содержимому поля `DefaultValue` добавится тег изначального цвета текста:
     > ![](..\images\image201.png)

   ```xml
    "<font color=\"#000000\">Text Sample</font>"
   ```

3. Настройте плавность линий, отображающих текст:
   1. Выберите текстовой слой.
      ![](..\images\image125.png)
   2. В разделе `Properties` измените параметр `StepCount` на желаемый:
      ![](..\images\image173.png)

> Примеры значений параметра `StepCount`:<br>

    `StepCount` = 1:
    <br>![](..\images\image89.png)<br>
    `StepCount` = 2:
    <br>![](..\images\image161.png)<br>
    `StepCount` = 4:
    <br>![](..\images\image107.png)<br>
    <br>Примечание: чем больше значение параметра `StepCount`, тем больше потребляется ресурсов ГП на отрисовку текста.

## Подготовка UE4 проекта к экспорту шаблона (старый плагин)

Для подготовки проекта к экспорту шаблона необходимо выполнить следующее:

1. Запустите проект, который необходимо экспортировать, включите плагины `Carrot` и `CarrotEditor` и перезапустите проект:

   ![](..\images\image10.png)

2. В разделе `Project` - `Maps & Modes` - `Default Maps` в параметрах `Editor Startup Map` и `Game Default Map` укажите ту сцену, которую предполагается использовать.

   ![](..\images\image143.png)

3. В настройках проекта в разделе `Engine` - `General Settings` - `Framerate` - `Custom TimeStep` укажите `CarrotCustomTimeStep`:

   ![](..\images\image79.png)

4. В разделе `Engine` - `Rendering` - `Default Settings` - `Anti-Aliasing Method` выбрать `TemporalAA`.

   ![](..\images\image141.png)

5. В настройках проекта в разделе `Engine` - `Rendering` - `Postprocessing` установите параметры, указанные ниже:

   ![](..\images\image169.png)

6. В настройках проекта в разделе `Engine` - `Rendering` - `Default Settings` установите параметр `Frame Buffer Pixel Format` равным `Float RGBA`:

   ![](..\images\image106.png)

7. Добавьте в сцену `Empty Actor` - этот объект будет отвечать за смещения координат, получаемых от **Carrot Tracking Server**.

   ![](..\images\image126.png)

8. Добавьте в сцену `Cine Camera Actor` - этот объект будет выполнять роль виртуальной камеры

   ![](..\images\image53.png)

9. Сделайте `Empty Actor` родительским объектом по отношению к `Cine Camera Actor`

   ![](..\images\image32.png)

10. Откройте свойства `Cine Camera Actor` и в разделе `Current Camera Settings` - `Lens Settings` установите параметр `Min Focal Length` равным 0 мм.

    ![](..\images\image76.png)

11. Выберите компонент `CameraComponent` и добавьте к нему компонент `SceneCaptureComponent2D`.

    ![](..\images\image86.png)

12. Создайте `Render Target` - эта текстура будет использоваться для вывода изображения.

    ![](..\images\image66.png)

13. Настройки данной текстуры приведите в соответствие с указанными ниже:

    ![](..\images\image178.png)

    > Примечание: разрешение текстуры должно совпадать с разрешением вьюпорта, на котором она будет проигрываться (см. 4.3 Создание схемы работы Carrot Engine)

14. Скопируйте ассет `PostProcMat_Frames.uasset`, `PostProcMat_Alpha.uasset` и `CarrotMacroLibrary.uasset` в папку проекта

    ![](..\images\image179.png)
    ![](..\images\image85.png)

15. Откройте настройки компонента `SceneCaptureComponent2D` объекта `Cine Camera Actor` и установите параметры:

    ![](..\images\image146.png)

    - `Texture Target` - выберите ту `Render Target`, которую Вы создали для вывода изображения.
    - `Primitive Render Mode` - выберите `Render Scene Primitives`.
    - `Capture Source` - `Final Color (LDR) in RGB`.
    - `Capture Every Frame` - отключено.
    - `Capture on Movement` - отключено.
    - `Always Persist Rendering State` - включено.
    - `Temporal AA` - включено.

      ![](..\images\image148.png)

16. В разделе `Post Process Volume` - `Rendering Features` добавьте элементы и укажите пути на ассеты `PostProcMat_Alpha` и `PostProcMat_Frames` которые былы скопированы с плагином `Carrot`.

    ![](..\images\image60.png)

17. Если планируется завести изображение внутрь проекта, то создайте еще одну `Render Target` - эта текстура будет использоваться для ввода изображения. Таких текстур может быть несколько.

    ![](..\images\image66.png)

18. Настройки данной текстуры приведите в соответствие с указанными ниже:

    ![](..\images\image59.png)

    > Примечание: разрешение текстуры должно квадратным и кратным степени двойки (например, 256х256, 512х512, 2048х2048), а также близким с разрешением вьюпорта, с которого будет забираться изображение (см. 4.3 Создание схемы работы Carrot Engine)
    >
    > ![](..\images\image111.png)
    >
    > Если четкости входящей текстуры недостаточно - поставить `NoMipmaps`. В остальных случаях следует выбирать `Sharpen`.

19. Создайте материал, который будет использовать созданную `Render Target`:

    ![](..\images\image24.png)

20. Откройте настройки материала и задайте ему созданную текстуру:

    ![](..\images\image21.png)

21. Примените созданный материал на объект, на котором планируется отображать входящее изображение:

    ![](..\images\image171.png)

22. Откройте `Level Blueprint` и добавьте `Carrot Macro`.

    ![](..\images\image52.png)

23. Во входных параметрах `Carrot Macro` укажите:

    ![](..\images\image33.png)

    - `Event BeginPlay`
    - `Event Tick`
    - Объект `Cine Camera Actor`, используемый в качестве виртуальной камеры.
    - Объект `Empty Actor`, который является родительским по отношению к `Cine Camera Actor`.
    - `Input Render Target 2D` - указывается текстура, которая используется для ввода изображения.
    - `Output Render Target 2D` - указывается текстура, которая используется для вывода изображения.

    Если используется несколько текстур для входящих изображений, раскройте макрос:

    ![](..\images\image149.png)

    Необходимо скопировать ноду `Carrot Receiver` столько раз, сколько будет использоваться таких текстур.

    Причем первая текстура указывается в макросе, а последующие указываются в копиях ноды:

    ![](..\images\image101.png)

    Если подобные текстуры вообще не используются, необходимо исключить ноду `Carrot Receiver` из процесса:

    ![](..\images\image147.png)

24. Используйте выходные пины `Begin Play Out` и `Event Tick Out`, если ивенты `Begin Play` и `Event Tick` будут использоваться после `Carrot Macro`:

    ![](..\images\image33.png)

25. Если проигрывание шаблона проекта подразумевает использование команд, то:
    - Создайте ноду `Switch on String` и соедините её с Carrot Macro, как показано на рисунке выше.
    - Каждый выходной пин ноды `Switch on String` будет соответствовать команде, которую можно будет отправлять с `Carrot Playlist`.

Соедините выходные пины ноды `Switch on String` с теми событиями, которые должны выполниться при вызове команды, чьё имя соответствует имени пина.

26. В разделе `Editor` - `General` - `Performance` выключите параметр `Use Less CPU when in Background`.

    ![](..\images\image183.png)

## Подготовка UE4 проекта к экспорту шаблона (новый плагин)

Для подготовки проекта к экспорту шаблона необходимо выполнить следующее:

1. В дополнение к основным настройкам в проекте, в папке Config в файле DefaultEngine и в папке Windows в файле WindowsEngine необходимо добавить строки:

```text
[/Script/Engine.Engine]
GameEngine=/Script/Carrot.CarrotGameEngine
GameViewportClientClassName=/Script/Carrot.CarrotViewportClient
```

2. В разделе `Editor` - `General` - `Performance` выключите параметр `Use Less CPU when in Background`.

   ![](..\images\image183.png)

3. В разделе `Project` - `Engine` - `General Settings` в параметре `Game Viewport Client Class` выберите `CarrotViewportClient`.

   ![](..\images\image184.png)

4. Запустите проект, который необходимо экспортировать, включите плагины `Carrot` и `CarrotEditor` и перезапустите проект:

   ![](..\images\image10.png)

5. В разделе `Project` - `Maps & Modes` - `Default Maps` в параметрах `Editor Startup Map` и `Game Default Map` укажите ту сцену, которую предполагается использовать.

   ![](..\images\image143.png)

6. В настройках проекта в разделе `Engine` - `General Settings` - `Framerate` укажите:

- в поле `Custom TimeStep` укажите `CarrotCustomTimeStep`

  ![](..\images\image79.png)

4. Если в проекте используются анимации

5. В разделе `Engine` - `Rendering` - `Default Settings` - `Anti-Aliasing Method` выбрать `TemporalAA`.

   ![](..\images\image141.png)

6. В настройках проекта в разделе `Engine` - `Rendering` - `Postprocessing` установите параметры, указанные ниже:

   ![](..\images\image169.png)

7. В настройках проекта в разделе `Engine` - `Rendering` - `Default Settings` установите параметр `Frame Buffer Pixel Format` равным `8bit RGBA`:

   ![](..\images\image186.png)

8. Добавьте в сцену `Empty Actor` - этот объект будет отвечать за смещения координат, получаемых от **Carrot Tracking Server**.

   ![](..\images\image126.png)

9. Добавьте в сцену `Cine Camera Actor` - этот объект будет выполнять роль виртуальной камеры

   ![](..\images\image53.png)

10. Сделайте `Empty Actor` родительским объектом по отношению к `Cine Camera Actor`

    ![](..\images\image32.png)

11. Откройте свойства `Cine Camera Actor` и в разделе `Current Camera Settings` - `Lens Settings` установите параметр `Min Focal Length` равным 0 мм.

    ![](..\images\image190.png)

12. Добавьте в сцену `Post Process Volume`

    ![](..\images\image189.png)

13. Скопируйте ассет `PostProcMat_Frames.uasset`, `PostProcMat_Alpha.uasset` и `CarrotMacroLibrary.uasset` в папку проекта

14. В `Post Process Volume` - `Rendering Features` добавьте элементы и укажите пути на ассеты `PostProcMat_Alpha` и `PostProcMat_Frames` которые былы скопированы с плагином `Carrot`.

    ![](..\images\image187.png)

15. Также активируйте параметр `Infinite Extent (Unbound)`.

    ![](..\images\image188.png)

16. Если планируется завести изображение внутрь проекта, то создайте еще одну `Render Target` - эта текстура будет использоваться для ввода изображения. Таких текстур может быть несколько.

    ![](..\images\image66.png)

17. Настройки данной текстуры приведите в соответствие с указанными ниже:

    ![](..\images\image59.png)

    > Примечание: разрешение текстуры должно быть квадратным и кратным степени двойки (например, 256х256, 512х512, 2048х2048), а также близким с разрешением вьюпорта, с которого будет забираться изображение (см. 4.3 Создание схемы работы Carrot Engine)
    >
    > ![](..\images\image111.png)
    >
    > Если четкости входящей текстуры недостаточно - поставить `NoMipmaps`. В остальных случаях следует выбирать `Sharpen`.

18. Создайте материал, который будет использовать созданную `Render Target`:

    ![](..\images\image24.png)

19. Откройте настройки материала и задайте ему созданную текстуру:

    ![](..\images\image21.png)

20. Примените созданный материал на объект, на котором планируется отображать входящее изображение:

    ![](..\images\image171.png)

21. Откройте `Level Blueprint` и добавьте `Carrot Macro`.

    ![](..\images\image52.png)

22. Во входных параметрах `Carrot Macro` укажите:

    ![](..\images\image194.png)

    - `Event BeginPlay`
    - `Event Tick`
    - Объект `Cine Camera Actor`, используемый в качестве виртуальной камеры.
    - Объект `Empty Actor`, который является родительским по отношению к `Cine Camera Actor`.

    К выводу макроса `Event Tick Out` (или `Begin Play Out` **при использовании нового типа синхронизации**) добавьте ноду `Carrot Receiver` и укажите в ней текстуру:

    ![](..\images\image203.png)

    Если используется несколько текстур, необходимо скопировать ноду `Carrot Receiver` столько раз, сколько будет использоваться таких текстур.

    ![](..\images\image202.png)

    Если подобные текстуры вообще не используются, необходимо исключить ноду `Carrot Receiver` из процесса:

    ![](..\images\image204.png)

23. Используйте выходные пины `Begin Play Out` и `Event Tick Out`, если ивенты `Begin Play` и `Event Tick` будут использоваться после `Carrot Macro`:

    ![](..\images\image194.png)

24. Если проигрывание шаблона проекта подразумевает использование команд, то:

    - Создайте ноду `Switch on String` и соедините её с Carrot Macro.
    - Каждый выходной пин ноды `Switch on String` будет соответствовать команде, которую можно будет отправлять с `Carrot Playlist`.

    ![](..\images\image196.png)

Соедините выходные пины ноды `Switch on String` с теми событиями, которые должны выполниться при вызове команды, чьё имя соответствует имени пина.

## AR с использованием UE4

Отобразить в реальной студии объекты дополненной реальности

1.  Подготовка схемы для работы с AR:

        `System monitor` - `Engine` - `Add Engine` - `Введите имя схемы` - `Ok`

        ![](..\images\ar01.png)

        Выберите схему и нажмите `Add Workstation` и добавьте сервер на котором будет запущена схема

        ![](..\images\ar02.png)

        После этого нажмите `Edit Scheme` откроется окно `Flowchart`

        ![](..\images\ar03.png)

        Перетащите используемые вами ноды входного и выходного сигнал.

    Добавьте контейнер для шаблона UE4 правой клавишей мыши.
    Добавьте ПКМ ноду `AR` и подсоедините контейнер UE4 в `Foreground`, ноду с входящим видеосигналом в `Background`. Коннектор video подсоедините к ноде выходного видео сигнала, схема должна выглядеть как показано на скриншоте.

2.  Подготовка проекта UE4 для работы с AR

    Изначальная настройка проекта UE4 описана в пункте `Подготовка UE4 проекта к экспорту шаблона (новый плагин)`

    В `Project settings` - `Rendering` отключите `Ambient Occlusion` , `Auto Exposure` (`Motion Blur` если это необходимо) как показано на скриншоте

![](..\images\ar04.png)

Если Вам необходимы `Ambient Occlusion` в проекте используйте локальный `PostProccesVolume` с отключенной функцией `infiniti extent`.

`Carrot Engine` работает с `AR` на основе метода наложения `Screen\Add` по серому цвету. Мы рекомендуем создать все объекты для работы с AR в отдельном sublevel и вложить его в основной level проекта.

Нам необходимо создать следующие типы объектов:

- Серая циклорама
- Захватчик отражений и теней

`Серая циклорама` представляет из себя объект заполняющий весь видимый объем сцены это может быть куб, сфера либо заранее подготовленная модель с наложенным МАТЕРИАЛОМ(Пример настроек материала приведен на скриншоте).

![](..\images\ar05.png)

Пример объекта дополненной реальности в созданной циклораме

![](..\images\ar06.png)

3. Настройка Carrot Engine при работе с AR

   Экспорт шаблона происходит так же как описано в пункте `Экспорт шаблона из проекта UE4`

   Чтобы открыть панель настроек `Carrot AR`:
   `Carrot Engine` - `Tools` - `Show Content Settings`

   ![](..\images\ar07.png)

   Откроется окно настроек AR

   ![](..\images\ar08.png)

   В разделе `Gamma Correction` - `AR bg Color` нажмите на кнопку `Pick`, если серый цвет циклорамы выбран правильно значения `RGB Gamma` должны быть максимально близки к `1.000` как показано на скриншоте выше.

4. Получение отражений и теней с объектов дополненной реальности

   В UE4 необходимо необходимо создать `захватчик отражений и теней` представляет из себя 3D объект c наложенным МАТЕРИАЛОМ(Пример настроек материала приведен на скриншоте).

   ![](..\images\ar09.png)

   Параметрами `Metallic` и `Roughness` подбираем степень отражения объекта и видимость тени.

   В параметре `Base Color` подбираем серый цвет чтобы он соответствовал цвету циклорамы в зависимости от освещения в сцене результат должен выглядеть как на скриншоте

   ![](..\images\ar10.jpeg)

   Возможно использование всех видов отражений `SSR`, `Planar Reflections`, `RayTracing Reflections`.

   ![](..\images\ar11.png)

   В настройках `Carrot Engine` поставьте галочки `Enable` в разделах `Shadows` и `Highlights`.

   Для получения наилучших результатов используйте ползунки `levels` а также параметрами `Metallic` и `Roughness` в материале захватчика.

5. Дополнительная информация по настройкам сцен AR

   - Используйте `skylight` c `серой cubemap` как показано на скриншоте, чтобы избежать артефактов связанных с освещением

   ![](..\images\ar12.jpeg)

   - Используйте `Sphere Reflection Capture` работающей на всю сцену c `серой cubemap` как показано на скриншоте, чтобы избежать артефактов связанных отражениями. И локальные `Reflection Capture` которые работают локально на AR объекты.

   ![](..\images\ar13.jpeg)

   - Убедитесь что у Вас отключен эффект `Vignette` в камере которую использует Carrot и в `PostProcessVolume` он приводит к артефактам по краям кадра как показано на скриншоте.

   ![](..\images\ar14.jpeg)

   - На всех объектах находящиеся на сцене должен быть включен `Render CustomDepth Pass` c параметром `CustomDepth Stencil Value` `255` как показано на скриншоте, иначе объекты будут полупрозрачными.

   ![](..\images\ar15.jpeg)

   - Для работа с полупрозрачными объектами (стеклянными) мы советуем не использовать сложные шейдеры в материалах, а использовать `CustomDepth Stencil Value` для получения нужной прозрачности объекта.

   - Нельзя использовать цветокор в `PostProcessVolume` это приводит к возникновению цветовых артефактов. Цветокора ue4 сцены осуществляется через `Carrot Engine` вкладка `BG`

## Экспорт шаблона из проекта UE4

Для экспорта шаблона из проекта UE4 необходимо выполнить следующее:

1. Нажмите кнопку `Export Carrot` (расположена на верхней панели):

   ![](..\images\image35.png)

2. Откроется окно `Carrot Objects`:

   ![](..\images\image160.png)

   В данном окне будут отображаться только те объекты проекта, которые будут использоваться для интеграции с **ПО Carrot**:

   - Текстуры для входных изображений;
   - Текстура выходного изображения;
   - Список команд.

3. Выберите режим сохранения шаблона:

   ![](..\images\image195.png)

   `Unreal Editor` - сохранится только шаблон проекта. Данный режим используется, когда запуск проекта происходит посредством `Unreal Editor`.
   `Already Packed Project` - указывается путь к уже собранному проекту. Происходит его упаковка и сохранение в **Carrot Server** вместе с шаблоном. Данный режим используется, когда нужен запуск собранного проекта.

4. Нажмите кнопку сохранения и выберите директорию сохранения:

   ![](..\images\image77.png)

5. В поле `Name` введите желаемое имя шаблона и нажмите `Save Template`.

6. Закройте окно `Carrot Objects`:

   ![](..\images\image88.png)

   > Примечание:
   >
   > - при запуске собранного проекта его окно должно быть развернуто;
   > - при запуске сцены из-под `UE Editor` окно сцены должно быть развернуто, а окно `UE Editor` должно быть свернуто.



## Создание плейлиста

Для проигрывания экспортированных шаблонов необходимо создать плейлист, с которого будут отправляться команды на их проигрывание.

Для этого:

1. Запустите `Carrot Web Playlist` зайдите через браузер на страницу управления плейлистами.
2. Выберите пункт `Editor`

   ![](..\images\image44.png)

3. Нажмите кнопку `NEW`.
   Откроется вкладка создания нового плейлиста.

   В разделе `Enter Playlist Name` введите имя будущего плейлиста.

   Нажмите `OK`.

   ![](..\images\image84.png)

4. Окно `Editor` состоит из трех областей

   - Область настройки плейлиста (выделена красным) служит для настройки очередности событий в плейлисте
   - Область `Templates` (выделена зеленым) тут хранятся загруженные на сервер шаблоны
   - Область `Properties` (выделена синим) служит для настройки поведения конкретного шаблона в плейлисте.

   ![](..\images\image20.png)

5. Заполнение плейлиста:

   - Плейлист заполняет перетягиваем мышки (Drug and Drop) шаблона из области `Templates` в область плейлиста.

6. Меню редактирования плейлиста

   ![](..\images\image56.png)

   - `Add store` - добавляет новую пустую историю в плейлист
   - `Group` - группирует шаблоны в плейлисте
   - `Rename story` - переименовывает выбранную историю
   - `Remove item` - удаляет выбранный шаблон из истории
   - `Remove story` - удаляет историю с находящимися внутри шаблонами

7. Раздел `Properties`

   ![](..\images\image83.png)

   `Name` - имя шаблона которое будет отображаться в плейлисте.
   `Template name` - имя шаблона задается при сохранении на сервер.
   `State` - стейт с которого будет воспроизводиться шаблон.
   `Новость\Улица` - Текстовое параметрическое поле задается при создании шаблона.
   `Back\Face` - `Media input` для отображения в шаблоне медиаданных (фото, видео файлов а так же захват изображения с карты захвата)
   поля задаются при создании шаблона.

   Окно для указания `media inputs` в шаблоне:

   ![](..\images\image50.png)

   - `Media Assets Library` - библиотека загруженных медиа файлов
   - `Inputs` - Вход для видео потока (Карта захвата, WebRTC, другие шаблоны)

## Проигрывание плейлиста

![](..\images\image133.png)

- `Load` - загружает выбранное события в плейлисте.
- `Load all` - загружает все события в плейлисте.
- `In` - загружает и переводит активирует событие выбранное событие в плейлисте.
- `Next` - деактивирует выделенное событие в плейлисте и активирует нижестоящее событие.
- `Out` - деактивирует выделенное событие в плейлисте.
- `Unload` - выгружает выбранное события в плейлисте.
- `Unload all` - выгружает все события в плейлисте.

Выберите интересующий вас шаблон ЛКМ его фон станет серым, как показано на скриншоте:

![](..\images\image64.png)

Перед воспроизведение его надо загрузить в оперативную память это можно сделать кнопкой `Load` либо `ПРОБЕЛ` с клавиатуры (если вам нужно загрузить весь `playlist` можно воспользоваться кнопкой `load all`).

После того как шаблон был загружен цвет его теста станет черным, а `Status` измениться на `Ready`, как показано на скриншоте:

![](..\images\image29.png)

Теперь данный шаблон можно воспроизвести с помощью кнопки `IN` либо `ПРОБЕЛ` с клавиатуры, цвет строки станет зеленым, а `Status` измениться на `Active`, как показано на скриншоте:

![](..\images\image122.png)

Чтобы завершить воспроизведение (либо проиграть выходной стейт)

нажмите клавишу `OUT`, как только воспроизведение закончиться `Status` измениться на `Ready` и зеленая подсветка отключиться.

Шаблоны находящиеся в `Status Active` не подлежат редактированию!!!

Перед редактирование шаблона его обязательно надо перевести в `Status Ready`.

Если Вам необходимо перезалить шаблон с тем же именем файла, шаблон должен находиться в `Status Unloaded` перед загрузкой.

## Добавление специальных событий

Для добавления специальных событий необходимо выполнить следующее:

В меню редактирования плейлиста выберите `Add Special Event`

![](..\images\image205.png)

### Типы специальных событий

1. `Reset` - восстановление буферов вызывается у движков, которые задействованы в этом плейлисте.
1. `StopPlaylist` - убирает с показа все шаблоны плейлиста катом. (аналог кнопки Panic).
1. `TextCommand` - передача текстовой команды напрямую в движки, задействованные в плейлисте

### Список `TextCommand`:

1. ApplySettingsToContent - применение настроек (на текущий момент только для контента Keyer).
1. RestartContent - рестарт контента (на текущий момент только для контента Ticker).
1. TakeOutContainer - вызов TakeOut у шаблонов, показывающихся на конкретном контейнере.
1. SetGlobalVar - изменение глобальной переменной.

#### 1. `ApplySettingsToContent`

![](..\images\image206.png)

`Содержимое команды`:

%Command=[ApplySettingsToContent] %ContentName=[Имя контента в схеме] %SettingsPath=[путь к файлу с настройками] %SaveSettingsToDB=[True или False]

`Пример`:

%Command=[ApplySettingsToContent] %ContentName=[Keyer] %SettingsPath=[D:\KeyerSettings\key test 14-01-22.xml] %SaveSettingsToDB=[False]

Соответственно, на каждом компьютере по этому пути должен быть файл с настройками.

Если %SaveSettingsToDB=[True] (или этого параметра нет вообще), то при выполнении команды настройки применяются и сохраняются в БД, то есть при следующем запуске они восстановятся.

#### 2. `RestartContent`

`Содержимое команды`:

%Command=[RestartContent] %ContentName=[Имя контента в схеме]

`Пример`:

%Command=[RestartContent] %ContentName=[Ticker]

Тикер перенесет все строки в начало.

#### 3. `TakeOutContainer`

`Содержимое команды`:

%Command=[TakeOutContainer] %ContainerName=[Имя контейнера в схеме]

`Пример`:

%Command=[TakeOutContainer] %ContainerName=[AE 2D]

Шаблоны, которые рисуются в контейнере AE 2D уйдут с анимацией выхода

#### 4. `SetGlobalVar`

`Содержимое команды`:

%Command=[SetGlobalVar] %GlobalVarName=[Имя переменной] %GlobalVarValue=[значение переменной]

`Пример`:

%Command=[SetGlobalVar] %GlobalVarName=[title] %GlobalVarValue=[заголовок]

## Настройка задержек ввода/вывода

Для настройки задержек необходимо выполнить следующее:

Откройте меню `Carrot Engine` - `Delays` - `Show Delays Form`

![](..\images\image16.png)

Откроется форма настройки задержек

![](..\images\image108.png)

- `Input Delay Offset` - покадровая задержка входящего видео потока
- `Tracking Delay` - покадровая задержка данных из трекинг системы
- `Apply` - применить изменения
- `Стрелка` - служит для сброса `output delay` в `Carrot Engine`.
